import Post from '../../components/Post'
import Show from '../../components/Show'
import Info from '../../components/Info'
import Divider from '../../components/Divider'
import ScrollToTop from '../../components/ScrollToTop'
import FooterEnd from '../../components/FooterEnd'
import DemoAndSource from '../../components/DemoAndSource'

import { data } from '../../data/make-an-auto-hiding-header.js'

export const meta = {
  title: 'Make an auto-hiding Header',
  description: "Let's build a Header that hides when you scroll.",
  date: 'March 13, 2021',
  coverImage: '/images/make-auto-hide-header/cover-image.png',
}

export default ({ children }) => <Post meta={meta}>{children}</Post>

# Make an auto-hiding Header

<ScrollToTop />

![Cover Image](/images/make-auto-hide-header/cover-image-large.png)

Hey everyone! I'm quite fond of maximizing my view of web page content. Therefore, not having the header blocking my reading area is essential. Today, I'm going to show you how to make an auto-hiding header, very similar to the one currently on this site. 

Whenever we scroll down on our page, our header needs to hide itself. When we scroll back up, our header then needs to re-appear. I will be building this using ReactJS and Emotion. This guide assumes you have your ReactJS project already setup, so if not, quickly run `create-react-app` and we will continue. 

<DemoAndSource demo="https://nownano-guides.vercel.app/" source="https://github.com/Technopathic/NowNano-Guides/blob/main/src/components/Header.jsx" />

<Divider />

## Emotion
Emotion is a CSS-in-JS library, my favourite and most often used one. If you're unfamiliar with CSS-in-JS, it allows us to write CSS tyles with JavaScript. This gives us a powerful way to dynamically manipulate the elements on our page. We will be using Emotion to add styles and animations to our  `Header` component. 

Let's go ahead and install Emotion.
```
npm install @emotion/react @emotion/styled --save
```

We will mainly be using `@emotion/styled`, but we also need `@emotion/react` because it is a dependency. If you are familiar with Styled-Components, Emotion is quite smililar. 

<Divider />

## Creating our Header Component
In our project, go ahead and create a `Header.jsx` file in our `components` folder. We will first create our layout, our styles, and lastly the functional JavaScript. 

## Header layout
Our layout will be similar to the Header you see on this website. We will have a left-side for our site name and a right-side for our navigation links. These two elements will be justified apart from each other and have a maximum width of `1024px`.

![Code Snippet](/images/make-auto-hide-header/0.svg)

<Show label="Code" content={0} data={data}/>

You'll notice that I'm not using conventional HTML5. Instead, I'm using JSX styled components, which we will define using `Emotion`. 

<Divider />

## Emotion styles for our Header
At the top of our file, we will import our `@emotion/styled` library and define our styled components for our layout. 

Above our `Header` component, we will write our styled components code.

![Code Snippet](/images/make-auto-hide-header/1.svg)

<Show label="Code" content={1} data={data}/>

This is how we define our styled components with `Emotion`. We define them in a const variable using `styled.[element]` and we are using `header` here because semantically, this is a `header` for our website. We are making our `HeaderWrapper` with a black background, but slighly transparent. We are using `display:flex`, `justify-content: center`, and `align-items:center` to position the inner content of our `HeaderWrapper` to an appropriate location. Lastly, we will use `position: fixed` and its corresponding `top`, `left`, `right`, and `z-index` values to set our `HeaderWrapper` as a layer which will always appear above all other content on our website. 

Let's continue with the rest of our Emotion styled components. 

![Code Snippet](/images/make-auto-hide-header/2.svg)

<Show label="Code" content={2} data={data}/>

The importance of our `Section` is to both separate our `SiteName` and `Navigation` styled components, while also limiting the width to `1024px` to prevent them from awkwardly spreading across larger screens. Our `SiteName` will make our website's name or logo slightly more readable, as an actual production header should be. Next, our `Navigation` will position our `NavLink` items vertically in the center of our header and our `NavLink` styled components will apply padding and margins between each of our links. I am also changing the color of the navigation links to white, to avoid the awful default hyperlink blue color. 

You'll also notice, I've added a `&:hover` to our `NavLink`. This is one of my personal favourite parts of `Emotion`, the ability to add nested styles right into the styled component. This makes the code far easier to maintain and understand as compared to plain CSS. Granted, this is only an opinion of mine. 

That should be all for our Emotion styles. We will now add JavaScript functions to hide our `Header` component whenever we scroll down and reappear when we scroll back up. 

<Divider />

## Fun with Header functions

This is honestly my favourite part about any guide, and that is adding some sort of functionality with JavaScript. As we said above, we are going to add a function to control the state of our `Header`, whether it is visible or not, and we will track our scroll position. 

Let's start by importing `useState` and `useEffect`, built-in React hooks we can use to store the state of our `Header` component and listen for any scroll updates. At the top of our `Header.jsx`:

![Code Snippet](/images/make-auto-hide-header/3.svg)

<Show label="Code" content={3} data={data}/>

Now we will add the states that we will be controlling within our `Header` component. 

![Code Snippet](/images/make-auto-hide-header/4.svg)

<Show label="Code" content={4} data={data}/>

Here we are creating two states, `show` for controlling if our `Header` component is visible within the viewport and `scrollPos`, which will be used to check if our user is at the top of the page and if they have moved downwards or upwards. Now let's create a function which will update our `scrollPos` on scroll, and update our `show` if the conditions previously specified are correct.

![Code Snippet](/images/make-auto-hide-header/5.svg)

<Show label="Code" content={5} data={data}/>

Here we are making use of `getBoundingClientRect().top`, a useful built-in JavaScript function which we can use to get the distance our user is from the top of the page. In our `if` statement, we are checking if the user is at the top of the page, in which case, we want to set `show` to `true`, which will make our `Header` component visible. We are also setting our `scrollPos` to `0`, since we are at the top of the page. The `else` statement will set `scrollPos` to the distance the user is from the top of the page and check if the current scroll position is greater than what is previously stored in `scrollPos`. If the current scroll position is greater than the previously stored `scrollPos`, we will show our `Header` component, as this would imply the user has scrolled upwards. 

Now that we have our `handleScroll` function to keep track of our users' scrolling habits, we can implement this function to always listen for our user using the `useEffect` hook. 

![Code Snippet](/images/make-auto-hide-header/6.svg)

<Show label="Code" content={6} data={data}/>

In this case, `useEffect` will check for updates on our states, then re-render the page accordingly. For example, if `show` were to be updated from `true` to `false`, `useEffect` will quietly re-render the component to reflect this and hide the `Header`.

We are using `window.addEventListener("scroll", ...)` here to listen for any scroll events emitted by our users' interaction with their browser. Everytime the user scrolls, our `handleScroll` function will trigger. Then our `useEffect` will re-render our component, it's all essentally one big chain reaction. Lastly, we add a `return () => {...}` to stop our component from listening to scroll events if our component is unmounted. This is useful for keeping your `Header` visible when you're switching between pages, otherwise React won't reset our `show` state to `true` and your users may have a strange user experience. 

<Divider />

## Revisiting our HeaderWrapper
This is where `Emotion` really shines with the ability to pass `props` to our styled components. We will pass our `show` state to our `HeaderWrapper` styled component and use to that to animate our `Header` sliding up and down into view. 

![Code Snippet](/images/make-auto-hide-header/7.svg)

<Show label="Code" content={7} data={data}/>

Next, we will add some additional `transform` and `transition` code to our `HeaderWrapper` styled component to give it a pleasant animation. 

![Code Snippet](/images/make-auto-hide-header/8.svg)

<Show label="Code" content={8} data={data}/>

Now I absolutely love using ternary operators when doing conditional styles. Our `transform` accepts the `props` being passed to the `HeaderWrapper` and uses the `show` prop. If the `show` prop is `true`, we use `translate3d` to position our `HeaderWrapper` to `0px`, specifically on the y-axis. If our `props.show` should be `false`, we move our `HeaderWrapper` up the y-axis using `-60px`, (the same height as the `Header`) which should be enough to hide it from view. Additionally, we add `transition` to ensure that our `transform` moves our styled component smoothly using `ease` and a duratoin of `0.3s`. Without this, our `HeaderWrapper` would blink out of existence. 

<Divider />

## Bonus Filter
This is a small addition which most people probably won't notice, but those who do may appreciate it. Some of you have pointed out that there's a really neat "frosted glass" effect on my `Header` as well. I should note, this currently only works on Google Chrome. 

![Code Snippet](/images/make-auto-hide-header/9.svg)

<Show label="Code" content={9} data={data}/>

## Final Words
That should wrap up everything for our `Header` component. You can go ahead and implement your header now onto any of your pages or your project's root page to make it visible on all of your pages. 

You can find the final source code for the entire component in the link below. You will also find the official `NowNano-Guides` repo, which will be a repository for guides which do not require needing their own full project repo. With the new Guides repo, you can run each demo right from one code base for convenience. 

<FooterEnd 
    title="Congratulations!" 
    message="You've reached the end of this guide! You can check out the demo and source code down below. While you're at it, consider supporting the blog, it helps keep me motivated to create more guides and I greatly appreciate it." 
    related={[{ title: 'Creating a Jamstack blog', url: '/Creating-a-Jamstack-blog'}]} 
    demo="https://nownano-guides.vercel.app/"
    source="https://github.com/Technopathic/NowNano-Guides/blob/main/src/components/Header.jsx"
/>